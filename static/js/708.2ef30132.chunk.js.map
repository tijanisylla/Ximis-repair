{"version":3,"file":"static/js/708.2ef30132.chunk.js","mappings":"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","sources":["../node_modules/@radix-ui/react-use-layout-effect/src/use-layout-effect.tsx","../node_modules/@radix-ui/primitive/src/primitive.tsx","../node_modules/@radix-ui/react-context/src/create-context.tsx","../node_modules/@radix-ui/react-presence/src/presence.tsx","../node_modules/@radix-ui/react-presence/src/use-state-machine.tsx","../node_modules/@radix-ui/react-use-controllable-state/src/use-controllable-state.tsx","../node_modules/@radix-ui/react-use-controllable-state/src/use-controllable-state-reducer.tsx","../node_modules/@radix-ui/react-direction/src/direction.tsx","../node_modules/@radix-ui/react-id/src/id.tsx","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js","../node_modules/@babel/runtime/helpers/esm/checkPrivateRedeclaration.js","../node_modules/@babel/runtime/helpers/esm/assertClassBrand.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js","../node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-slot/src/slot.tsx","../node_modules/@radix-ui/react-collection/src/collection-legacy.tsx","../node_modules/@radix-ui/react-collection/src/ordered-dictionary.ts","../node_modules/@radix-ui/react-use-callback-ref/src/use-callback-ref.tsx","../node_modules/@radix-ui/react-primitive/node_modules/@radix-ui/react-slot/src/slot.tsx","../node_modules/@radix-ui/react-primitive/src/primitive.tsx","../node_modules/lucide-react/src/icons/calendar.ts"],"sourcesContent":["import * as React from 'react';\n\n/**\n * On the server, React emits a warning when calling `useLayoutEffect`.\n * This is because neither `useLayoutEffect` nor `useEffect` run on the server.\n * We use this safe version which suppresses the warning by replacing it with a noop on the server.\n *\n * See: https://reactjs.org/docs/hooks-reference.html#uselayouteffect\n */\nconst useLayoutEffect = globalThis?.document ? React.useLayoutEffect : () => {};\n\nexport { useLayoutEffect };\n","/* eslint-disable no-restricted-properties */\n\n/* eslint-disable no-restricted-globals */\nexport const canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n/* eslint-enable no-restricted-globals */\n\nexport function composeEventHandlers<E extends { defaultPrevented: boolean }>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !event.defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\nexport function getOwnerWindow(element: Node | null | undefined) {\n  if (!canUseDOM) {\n    throw new Error('Cannot access window outside of the DOM');\n  }\n  // eslint-disable-next-line no-restricted-globals\n  return element?.ownerDocument?.defaultView ?? window;\n}\n\nexport function getOwnerDocument(element: Node | null | undefined) {\n  if (!canUseDOM) {\n    throw new Error('Cannot access document outside of the DOM');\n  }\n  // eslint-disable-next-line no-restricted-globals\n  return element?.ownerDocument ?? document;\n}\n\n/**\n * Lifted from https://github.com/ariakit/ariakit/blob/main/packages/ariakit-core/src/utils/dom.ts#L37\n * MIT License, Copyright (c) AriaKit.\n */\nexport function getActiveElement(\n  node: Node | null | undefined,\n  activeDescendant = false\n): HTMLElement | null {\n  const { activeElement } = getOwnerDocument(node);\n  if (!activeElement?.nodeName) {\n    // `activeElement` might be an empty object if we're interacting with elements\n    // inside of an iframe.\n    return null;\n  }\n\n  if (isFrame(activeElement) && activeElement.contentDocument) {\n    return getActiveElement(activeElement.contentDocument.body, activeDescendant);\n  }\n\n  if (activeDescendant) {\n    const id = activeElement.getAttribute('aria-activedescendant');\n    if (id) {\n      const element = getOwnerDocument(activeElement).getElementById(id);\n      if (element) {\n        return element;\n      }\n    }\n  }\n\n  return activeElement as HTMLElement | null;\n}\n\nexport function isFrame(element: Element): element is HTMLIFrameElement {\n  return element.tagName === 'IFRAME';\n}\n","import * as React from 'react';\n\nfunction createContext<ContextValueType extends object | null>(\n  rootComponentName: string,\n  defaultContext?: ContextValueType\n) {\n  const Context = React.createContext<ContextValueType | undefined>(defaultContext);\n\n  const Provider: React.FC<ContextValueType & { children: React.ReactNode }> = (props) => {\n    const { children, ...context } = props;\n    // Only re-memoize when prop values change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  };\n\n  Provider.displayName = rootComponentName + 'Provider';\n\n  function useContext(consumerName: string) {\n    const context = React.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== undefined) return defaultContext;\n    // if a defaultContext wasn't specified, it's a required context.\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n\n  return [Provider, useContext] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/\n\ntype Scope<C = any> = { [scopeName: string]: React.Context<C>[] } | undefined;\ntype ScopeHook = (scope: Scope) => { [__scopeProp: string]: Scope };\ninterface CreateScope {\n  scopeName: string;\n  (): ScopeHook;\n}\n\nfunction createContextScope(scopeName: string, createContextScopeDeps: CreateScope[] = []) {\n  let defaultContexts: any[] = [];\n\n  /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/\n\n  function createContext<ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) {\n    const BaseContext = React.createContext<ContextValueType | undefined>(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n\n    const Provider: React.FC<\n      ContextValueType & { scope: Scope<ContextValueType>; children: React.ReactNode }\n    > = (props) => {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      // Only re-memoize when prop values change\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n      return <Context.Provider value={value}>{children}</Context.Provider>;\n    };\n\n    Provider.displayName = rootComponentName + 'Provider';\n\n    function useContext(consumerName: string, scope: Scope<ContextValueType | undefined>) {\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const context = React.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== undefined) return defaultContext;\n      // if a defaultContext wasn't specified, it's a required context.\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n\n    return [Provider, useContext] as const;\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/\n\n  const createScope: CreateScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext);\n    });\n    return function useScope(scope: Scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n\n  createScope.scopeName = scopeName;\n  return [createContext, composeContextScopes(createScope, ...createContextScopeDeps)] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/\n\nfunction composeContextScopes(...scopes: CreateScope[]) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n\n  const createScope: CreateScope = () => {\n    const scopeHooks = scopes.map((createScope) => ({\n      useScope: createScope(),\n      scopeName: createScope.scopeName,\n    }));\n\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        // We are calling a hook inside a callback which React warns against to avoid inconsistent\n        // renders, however, scoping doesn't have render side effects so we ignore the rule.\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes, ...currentScope };\n      }, {});\n\n      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nexport { createContext, createContextScope };\nexport type { CreateScope, Scope };\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './use-state-machine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement<{ ref?: React.Ref<HTMLElement> }>;\n\n  const ref = useComposedRefs(presence.ref, getElementRef(child));\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration | null>(null);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      let timeoutId: number;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        // The event.animationName is unescaped for CSS syntax,\n        // so we need to escape it to compare with the animationName computed from the style.\n        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied a frame after the\n          // animation ends, creating a flash of visible content. By setting the\n          // animation fill mode to \"forwards\", we force the node to keep the\n          // styles of the last keyframe, removing the flash.\n          //\n          // Previously we flushed the update via ReactDom.flushSync, but with\n          // exit animations this resulted in the node being removed from the\n          // DOM before the synthetic animationEnd event was dispatched, meaning\n          // user-provided event handlers would not be called.\n          // https://github.com/radix-ui/primitives/pull/1849\n          send('ANIMATION_END');\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = 'forwards';\n            // Reset the style after the node had time to unmount (for cases\n            // where the component chooses not to unmount). Doing this any\n            // sooner than `setTimeout` (e.g. with `requestAnimationFrame`)\n            // still causes a flash.\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === 'forwards') {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      stylesRef.current = node ? getComputedStyle(node) : null;\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles: CSSStyleDeclaration | null) {\n  return styles?.animationName || 'none';\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement<{ ref?: React.Ref<unknown> }>) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  // Not DEV\n  return element.props.ref || (element as any).ref;\n}\n\nconst Root = Presence;\n\nexport {\n  Presence,\n  //\n  Root,\n};\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// ðŸ¤¯ https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n","import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// Prevent bundlers from trying to optimize the import\nconst useInsertionEffect: typeof useLayoutEffect =\n  (React as any)[' useInsertionEffect '.trim().toString()] || useLayoutEffect;\n\ntype ChangeHandler<T> = (state: T) => void;\ntype SetStateFn<T> = React.Dispatch<React.SetStateAction<T>>;\n\ninterface UseControllableStateParams<T> {\n  prop?: T | undefined;\n  defaultProp: T;\n  onChange?: ChangeHandler<T>;\n  caller?: string;\n}\n\nexport function useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n  caller,\n}: UseControllableStateParams<T>): [T, SetStateFn<T>] {\n  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({\n    defaultProp,\n    onChange,\n  });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(prop !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  const setValue = React.useCallback<SetStateFn<T>>(\n    (nextValue) => {\n      if (isControlled) {\n        const value = isFunction(nextValue) ? nextValue(prop) : nextValue;\n        if (value !== prop) {\n          onChangeRef.current?.(value);\n        }\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, onChangeRef]\n  );\n\n  return [value, setValue];\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, 'prop'>): [\n  Value: T,\n  setValue: React.Dispatch<React.SetStateAction<T>>,\n  OnChangeRef: React.RefObject<ChangeHandler<T> | undefined>,\n] {\n  const [value, setValue] = React.useState(defaultProp);\n  const prevValueRef = React.useRef(value);\n\n  const onChangeRef = React.useRef(onChange);\n  useInsertionEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      onChangeRef.current?.(value);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef]);\n\n  return [value, setValue, onChangeRef];\n}\n\nfunction isFunction(value: unknown): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","import * as React from 'react';\nimport { useEffectEvent } from '@radix-ui/react-use-effect-event';\n\ntype ChangeHandler<T> = (state: T) => void;\n\ninterface UseControllableStateParams<T> {\n  prop: T | undefined;\n  defaultProp: T;\n  onChange: ChangeHandler<T> | undefined;\n  caller: string;\n}\n\ninterface AnyAction {\n  type: string;\n}\n\nconst SYNC_STATE = Symbol('RADIX:SYNC_STATE');\n\ninterface SyncStateAction<T> {\n  type: typeof SYNC_STATE;\n  state: T;\n}\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialState: S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, I, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: I,\n  init: (i: I & { state: T }) => S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: any,\n  init?: (i: any) => Omit<S, 'state'>\n): [S & { state: T }, React.Dispatch<A>] {\n  const { prop: controlledState, defaultProp, onChange: onChangeProp, caller } = userArgs;\n  const isControlled = controlledState !== undefined;\n\n  const onChange = useEffectEvent(onChangeProp);\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(controlledState !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  type InternalState = S & { state: T };\n  const args: [InternalState] = [{ ...initialArg, state: defaultProp }];\n  if (init) {\n    // @ts-expect-error\n    args.push(init);\n  }\n\n  const [internalState, dispatch] = React.useReducer(\n    (state: InternalState, action: A | SyncStateAction<T>): InternalState => {\n      if (action.type === SYNC_STATE) {\n        return { ...state, state: action.state };\n      }\n\n      const next = reducer(state, action);\n      if (isControlled && !Object.is(next.state, state.state)) {\n        onChange(next.state);\n      }\n      return next;\n    },\n    ...args\n  );\n\n  const uncontrolledState = internalState.state;\n  const prevValueRef = React.useRef(uncontrolledState);\n  React.useEffect(() => {\n    if (prevValueRef.current !== uncontrolledState) {\n      prevValueRef.current = uncontrolledState;\n      if (!isControlled) {\n        onChange(uncontrolledState);\n      }\n    }\n  }, [onChange, uncontrolledState, prevValueRef, isControlled]);\n\n  const state = React.useMemo(() => {\n    const isControlled = controlledState !== undefined;\n    if (isControlled) {\n      return { ...internalState, state: controlledState };\n    }\n\n    return internalState;\n  }, [internalState, controlledState]);\n\n  React.useEffect(() => {\n    // Sync internal state for controlled components so that reducer is called\n    // with the correct state values\n    if (isControlled && !Object.is(controlledState, internalState.state)) {\n      dispatch({ type: SYNC_STATE, state: controlledState });\n    }\n  }, [controlledState, internalState.state, isControlled]);\n\n  return [state, dispatch as React.Dispatch<A>];\n}\n","import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\n/* -------------------------------------------------------------------------------------------------\n * Direction\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DirectionProviderProps {\n  children?: React.ReactNode;\n  dir: Direction;\n}\nconst DirectionProvider: React.FC<DirectionProviderProps> = (props) => {\n  const { dir, children } = props;\n  return <DirectionContext.Provider value={dir}>{children}</DirectionContext.Provider>;\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction useDirection(localDir?: Direction) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || 'ltr';\n}\n\nconst Provider = DirectionProvider;\n\nexport {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n};\n","import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// We spaces with `.trim().toString()` to prevent bundlers from trying to `import { useId } from 'react';`\nconst useReactId = (React as any)[' useId '.trim().toString()] || (() => undefined);\nlet count = 0;\n\nfunction useId(deterministicId?: string): string {\n  const [id, setId] = React.useState<string | undefined>(useReactId());\n  // React versions older than 18 will have client-side ids only.\n  useLayoutEffect(() => {\n    if (!deterministicId) setId((reactId) => reactId ?? String(count++));\n  }, [deterministicId]);\n  return deterministicId || (id ? `radix-${id}` : '');\n}\n\nexport { useId };\n","import checkPrivateRedeclaration from \"./checkPrivateRedeclaration.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nexport { _classPrivateFieldInitSpec as default };","function _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nexport { _checkPrivateRedeclaration as default };","function _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nexport { _assertClassBrand as default };","import assertClassBrand from \"./assertClassBrand.js\";\nfunction _classPrivateFieldGet2(s, a) {\n  return s.get(assertClassBrand(s, a));\n}\nexport { _classPrivateFieldGet2 as default };","import assertClassBrand from \"./assertClassBrand.js\";\nfunction _classPrivateFieldSet2(s, a, r) {\n  return s.set(assertClassBrand(s, a), r), r;\n}\nexport { _classPrivateFieldSet2 as default };","import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement)\n            ? (newElement.props as { children: React.ReactNode }).children\n            : null;\n        } else {\n          return child;\n        }\n      });\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {React.isValidElement(newElement)\n            ? React.cloneElement(newElement, undefined, newChildren)\n            : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== React.Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props);\n    }\n\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__radixId' in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>â€¦</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement | null>;\n    itemMap: Map<\n      React.RefObject<ItemElement | null>,\n      { ref: React.RefObject<ItemElement | null> } & ItemData\n    >;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n","// Not a real member because it shouldn't be accessible, but the super class\n// calls `set` which needs to read the instanciation state, so it can't be a\n// private member.\nconst __instanciated = new WeakMap<OrderedDict<any, any>, boolean>();\nexport class OrderedDict<K, V> extends Map<K, V> {\n  #keys: K[];\n\n  constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    super(entries);\n    this.#keys = [...super.keys()];\n    __instanciated.set(this, true);\n  }\n\n  set(key: K, value: V) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        this.#keys[this.#keys.indexOf(key)] = key;\n      } else {\n        this.#keys.push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n\n  insert(index: number, key: K, value: V) {\n    const has = this.has(key);\n    const length = this.#keys.length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n\n    if (safeIndex === this.size || (has && safeIndex === this.size - 1) || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n\n    const size = this.size + (has ? 0 : 1);\n\n    // If you insert at, say, -2, without this bit you'd replace the\n    // second-to-last item and push the rest up one, which means the new item is\n    // 3rd to last. This isn't very intuitive; inserting at -2 is more like\n    // saying \"make this item the second to last\".\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n\n    const keys = [...this.#keys];\n    let nextValue: V | undefined;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i]!;\n        if (keys[i] === key) {\n          nextKey = keys[i + 1]!;\n        }\n        if (has) {\n          // delete first to ensure that the item is moved to the end\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1]!;\n        const currentValue = nextValue!;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n\n  with(index: number, key: K, value: V) {\n    const copy = new OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n\n  before(key: K) {\n    const index = this.#keys.indexOf(key) - 1;\n    if (index < 0) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n\n  after(key: K) {\n    let index = this.#keys.indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n\n  first() {\n    return this.entryAt(0);\n  }\n\n  last() {\n    return this.entryAt(-1);\n  }\n\n  clear() {\n    this.#keys = [];\n    return super.clear();\n  }\n\n  delete(key: K) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      this.#keys.splice(this.#keys.indexOf(key), 1);\n    }\n    return deleted;\n  }\n\n  deleteAt(index: number) {\n    const key = this.keyAt(index);\n    if (key !== undefined) {\n      return this.delete(key);\n    }\n    return false;\n  }\n\n  at(index: number) {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return this.get(key);\n    }\n  }\n\n  entryAt(index: number): [K, V] | undefined {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return [key, this.get(key)!];\n    }\n  }\n\n  indexOf(key: K) {\n    return this.#keys.indexOf(key);\n  }\n\n  keyAt(index: number) {\n    return at(this.#keys, index);\n  }\n\n  from(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n\n  keyFrom(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n\n  find(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return undefined;\n  }\n\n  findIndex(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  filter<KK extends K, VV extends V>(\n    predicate: (entry: [K, V], index: number, dict: OrderedDict<K, V>) => entry is [KK, VV],\n    thisArg?: any\n  ): OrderedDict<KK, VV>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ): OrderedDict<K, V>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    const entries: Array<[K, V]> = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  map<U>(\n    callbackfn: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => U,\n    thisArg?: any\n  ): OrderedDict<K, U> {\n    const entries: [K, U][] = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduce<U>(\n    callbackfn: (\n      previousValue: U,\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduce<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue ?? this.at(0)!;\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduceRight<U>(\n    callbackfn: (\n      previousValue: [K, V],\n      currentValue: U,\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduceRight<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue ?? this.at(-1)!;\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index)!;\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n\n  toSorted(compareFn?: (a: [K, V], b: [K, V]) => number): OrderedDict<K, V> {\n    const entries = [...this.entries()].sort(compareFn);\n    return new OrderedDict(entries);\n  }\n\n  toReversed(): OrderedDict<K, V> {\n    const reversed = new OrderedDict<K, V>();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n\n  toSpliced(start: number, deleteCount?: number): OrderedDict<K, V>;\n  toSpliced(start: number, deleteCount: number, ...items: [K, V][]): OrderedDict<K, V>;\n\n  toSpliced(...args: [start: number, deleteCount: number, ...items: [K, V][]]) {\n    const entries = [...this.entries()];\n    entries.splice(...args);\n    return new OrderedDict(entries);\n  }\n\n  slice(start?: number, end?: number) {\n    const result = new OrderedDict<K, V>();\n    let stop = this.size - 1;\n\n    if (start === undefined) {\n      return result;\n    }\n\n    if (start < 0) {\n      start = start + this.size;\n    }\n\n    if (end !== undefined && end > 0) {\n      stop = end - 1;\n    }\n\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      result.set(key, element);\n    }\n    return result;\n  }\n\n  every(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n\n  some(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n}\n\nexport type KeyOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<infer K, any> ? K : never;\nexport type ValueOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<any, infer V> ? V : never;\nexport type EntryOf<D extends OrderedDict<any, any>> = [KeyOf<D>, ValueOf<D>];\nexport type KeyFrom<E extends EntryOf<any>> = E[0];\nexport type ValueFrom<E extends EntryOf<any>> = E[1];\n\nfunction at<T>(array: ArrayLike<T>, index: number): T | undefined {\n  if ('at' in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? undefined : array[actualIndex];\n}\n\nfunction toSafeIndex(array: ArrayLike<any>, index: number) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\n\nfunction toSafeInteger(number: number) {\n  // eslint-disable-next-line no-self-compare\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n","import * as React from 'react';\n\n/**\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\n * prop or avoid re-executing effects when passed as a dependency\n */\nfunction useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, []);\n}\n\nexport { useCallbackRef };\n","import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement)\n            ? (newElement.props as { children: React.ReactNode }).children\n            : null;\n        } else {\n          return child;\n        }\n      });\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {React.isValidElement(newElement)\n            ? React.cloneElement(newElement, undefined, newChildren)\n            : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== React.Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props);\n    }\n\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__radixId' in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { createSlot } from '@radix-ui/react-slot';\n\nconst NODES = [\n  'a',\n  'button',\n  'div',\n  'form',\n  'h2',\n  'h3',\n  'img',\n  'input',\n  'label',\n  'li',\n  'nav',\n  'ol',\n  'p',\n  'select',\n  'span',\n  'svg',\n  'ul',\n] as const;\n\ntype Primitives = { [E in (typeof NODES)[number]]: PrimitiveForwardRefComponent<E> };\ntype PrimitivePropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E> & {\n  asChild?: boolean;\n};\n\ninterface PrimitiveForwardRefComponent<E extends React.ElementType>\n  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}\n\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/\n\nconst Primitive = NODES.reduce((primitive, node) => {\n  const Slot = createSlot(`Primitive.${node}`);\n  const Node = React.forwardRef((props: PrimitivePropsWithRef<typeof node>, forwardedRef: any) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp: any = asChild ? Slot : node;\n\n    if (typeof window !== 'undefined') {\n      (window as any)[Symbol.for('radix-ui')] = true;\n    }\n\n    return <Comp {...primitiveProps} ref={forwardedRef} />;\n  });\n\n  Node.displayName = `Primitive.${node}`;\n\n  return { ...primitive, [node]: Node };\n}, {} as Primitives);\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Flush custom event dispatch\n * https://github.com/radix-ui/primitives/pull/1378\n *\n * React batches *all* event handlers since version 18, this introduces certain considerations when using custom event types.\n *\n * Internally, React prioritises events in the following order:\n *  - discrete\n *  - continuous\n *  - default\n *\n * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L294-L350\n *\n * `discrete` is an  important distinction as updates within these events are applied immediately.\n * React however, is not able to infer the priority of custom event types due to how they are detected internally.\n * Because of this, it's possible for updates from custom events to be unexpectedly batched when\n * dispatched by another `discrete` event.\n *\n * In order to ensure that updates from custom events are applied predictably, we need to manually flush the batch.\n * This utility should be used when dispatching a custom event from within another `discrete` event, this utility\n * is not necessary when dispatching known event types, or if dispatching a custom type inside a non-discrete event.\n * For example:\n *\n * dispatching a known click ðŸ‘Ž\n * target.dispatchEvent(new Event(â€˜clickâ€™))\n *\n * dispatching a custom type within a non-discrete event ðŸ‘Ž\n * onScroll={(event) => event.target.dispatchEvent(new CustomEvent(â€˜customTypeâ€™))}\n *\n * dispatching a custom type within a `discrete` event ðŸ‘\n * onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent(â€˜customTypeâ€™))}\n *\n * Note: though React classifies `focus`, `focusin` and `focusout` events as `discrete`, it's  not recommended to use\n * this utility with them. This is because it's possible for those handlers to be called implicitly during render\n * e.g. when focus is within a component as it is unmounted, or when managing focus on mount.\n */\n\nfunction dispatchDiscreteCustomEvent<E extends CustomEvent>(target: E['target'], event: E) {\n  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Primitive;\n\nexport {\n  Primitive,\n  //\n  Root,\n  //\n  dispatchDiscreteCustomEvent,\n};\nexport type { PrimitivePropsWithRef };\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M8 2v4', key: '1cmpym' }],\n  ['path', { d: 'M16 2v4', key: '4m81vk' }],\n  ['rect', { width: '18', height: '18', x: '3', y: '4', rx: '2', key: '1hopcy' }],\n  ['path', { d: 'M3 10h18', key: '8toen8' }],\n];\n\n/**\n * @component @name Calendar\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNOCAydjQiIC8+CiAgPHBhdGggZD0iTTE2IDJ2NCIgLz4KICA8cmVjdCB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHg9IjMiIHk9IjQiIHJ4PSIyIiAvPgogIDxwYXRoIGQ9Ik0zIDEwaDE4IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/calendar\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Calendar = createLucideIcon('calendar', __iconNode);\n\nexport default Calendar;\n"],"names":["useLayoutEffect2","globalThis","document","React","window","createElement","composeEventHandlers","originalEventHandler","ourEventHandler","checkForDefaultPrevented","arguments","length","undefined","event","defaultPrevented","createContextScope","scopeName","createContextScopeDeps","defaultContexts","createScope","scopeContexts","map","defaultContext","scope","contexts","concat","_objectSpread","rootComponentName","BaseContext","index","Provider","props","_scope$scopeName","children","context","_objectWithoutProperties","_excluded2","Context","value","Object","values","jsx","displayName","consumerName","_scope$scopeName2","Error","composeContextScopes","_len","scopes","Array","_key","baseScope","scopeHooks","createScope2","useScope","overrideScopes","nextScopes","reduce","nextScopes2","_ref","currentScope","Presence","present","presence","node","setNode","React2","stylesRef","prevPresentRef","prevAnimationNameRef","initialState","state","send","machine","nextState","useStateMachine","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","currentAnimationName","getAnimationName","current","useLayoutEffect","styles","wasPresent","prevAnimationName","display","_node$ownerDocument$d","timeoutId","ownerWindow","ownerDocument","defaultView","handleAnimationEnd","isCurrentAnimation","includes","CSS","escape","animationName","target","currentFillMode","style","animationFillMode","setTimeout","handleAnimationStart","addEventListener","clearTimeout","removeEventListener","isPresent","ref","node2","getComputedStyle","usePresence","child","only","useComposedRefs","element","_Object$getOwnPropert","_Object$getOwnPropert2","getter","getOwnPropertyDescriptor","get","mayWarn","isReactWarning","getElementRef","useInsertionEffect","trim","toString","useControllableState","prop","defaultProp","onChange","caller","uncontrolledProp","setUncontrolledProp","onChangeRef","_ref2","setValue","prevValueRef","_onChangeRef$current2","call","useUncontrolledState","isControlled","isControlledRef","wasControlled","from","to","console","warn","nextValue","value2","isFunction","_onChangeRef$current","Symbol","DirectionContext","useDirection","localDir","globalDir","useReactId","count","useId","deterministicId","id","setId","reactId","String","_classPrivateFieldInitSpec","e","t","a","has","TypeError","set","_assertClassBrand","n","_classPrivateFieldGet2","s","_classPrivateFieldSet2","r","createSlot","ownerName","SlotClone","createSlotClone","Slot2","forwardedRef","slotProps","_excluded","childrenArray","toArray","slottable","find","isSlottable","newElement","newChildren","childrenRef","props2","childProps","overrideProps","propName","slotPropValue","childPropValue","test","result","filter","Boolean","join","mergeProps","type","composeRefs","SLOTTABLE_IDENTIFIER","__radixId","createCollection","name","PROVIDER_NAME","createCollectionContext","createCollectionScope","CollectionProviderImpl","useCollectionContext","collectionRef","itemMap","Map","CollectionProvider","COLLECTION_SLOT_NAME","CollectionSlotImpl","CollectionSlot","composedRefs","ITEM_SLOT_NAME","ITEM_DATA_ATTR","CollectionItemSlotImpl","CollectionItemSlot","itemData","delete","Slot","ItemSlot","collectionNode","orderedNodes","querySelectorAll","sort","b","indexOf","__instanciated","WeakMap","_keys","at","array","prototype","actualIndex","relativeIndex","toSafeInteger","toSafeIndex","number","Math","trunc","useCallbackRef","callback","callbackRef","_callbackRef$current","args","Primitive","primitive","Node","asChild","primitiveProps","Comp","for","dispatchDiscreteCustomEvent","ReactDOM","dispatchEvent","Calendar","createLucideIcon","d","key","width","height","x","y","rx"],"ignoreList":[],"sourceRoot":""}